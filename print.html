<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mir</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        <!-- The following is taken from Ristretto: https://github.com/Ristretto/website/blob/master/site/theme/index.hbs -->
        

        <!-- Custom theme stuff -->
        <link rel="stylesheet" href="https://doc.dalek.rs/assets/katex/katex.min.css">
        <script src="https://doc.dalek.rs/assets/katex/katex.min.js"></script>
        <script src="https://doc.dalek.rs/assets/katex/contrib/auto-render.min.js"></script>
        <script>
        document.addEventListener("DOMContentLoaded", function() { renderMathInElement(document.body); });
        </script>
	      <!-- Comment out this style hook since mdbook's fonts are bigger than rustdoc's -->
        <style>
        .katex { font-size: 1em !important; }
        pre.rust, .docblock code, .docblock-short code { font-size: 0.85em !important; }
        </style>
	      <!-- -->
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="description.html"><strong aria-hidden="true">2.</strong> What is Mir?</a></li><li><a href="why.html"><strong aria-hidden="true">3.</strong> Why Mir?</a></li><li><ol class="section"><li><a href="why/criteria.html"><strong aria-hidden="true">3.1.</strong> Desired Properties</a></li><li><a href="why/related.html"><strong aria-hidden="true">3.2.</strong> Related Work</a></li><li><a href="why/advantages.html"><strong aria-hidden="true">3.3.</strong> Advantages of Mir</a></li></ol></li><li><a href="protocol.html"><strong aria-hidden="true">4.</strong> Mir Protocol</a></li><li><ol class="section"><li><a href="protocol/architecture.html"><strong aria-hidden="true">4.1.</strong> Architecture</a></li><li><a href="protocol/address.html"><strong aria-hidden="true">4.2.</strong> Address Mappings</a></li><li><ol class="section"><li><a href="protocol/cryptographic_wills.html"><strong aria-hidden="true">4.2.1.</strong> Cryptographic Wills</a></li><li><a href="protocol/format.html"><strong aria-hidden="true">4.2.2.</strong> Implementation</a></li><li><a href="protocol/delegation.html"><strong aria-hidden="true">4.2.3.</strong> Untrusted Delegation</a></li></ol></li><li><a href="protocol/identifier.html"><strong aria-hidden="true">4.3.</strong> Identifier Mappings</a></li><li><ol class="section"><li><a href="protocol/identity.html"><strong aria-hidden="true">4.3.1.</strong> Proofs of Identity</a></li><li><a href="protocol/zk_address_mapping.html"><strong aria-hidden="true">4.3.2.</strong> ZK Address Mapping</a></li></ol></li><li><a href="protocol/validation.html"><strong aria-hidden="true">4.4.</strong> Validation</a></li><li><a href="protocol/consensus.html"><strong aria-hidden="true">4.5.</strong> Consensus</a></li><li><a href="protocol/security.html"><strong aria-hidden="true">4.6.</strong> Security</a></li><li><a href="protocol/further_work.html"><strong aria-hidden="true">4.7.</strong> Further Work</a></li></ol></li><li><a href="applications.html"><strong aria-hidden="true">5.</strong> Usage and Applications</a></li><li><ol class="section"><li><a href="applications/authentication.html"><strong aria-hidden="true">5.1.</strong> Authentication</a></li><li><a href="applications/transaction.html"><strong aria-hidden="true">5.2.</strong> Transaction</a></li><li><a href="applications/communication.html"><strong aria-hidden="true">5.3.</strong> Communication</a></li><li><a href="applications/walled.html"><strong aria-hidden="true">5.4.</strong> Breaking Network Effects</a></li></ol></li><li><a href="faq.html"><strong aria-hidden="true">6.</strong> FAQ</a></li><li><a href="organization.html"><strong aria-hidden="true">7.</strong> Organization</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Mir</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introducing-mir" id="introducing-mir"><h1>Introducing Mir</h1></a>
<p><strong>Mir</strong> is a protocol for <strong>mapping identifiers</strong>, like social media accounts, email addresses, and names, to sets of public keys, and for <strong>recovering from the loss of private keys</strong>.</p>
<p>Mir allows anyone to use cryptographic protocols more easily and more securely, for things like authentication, payments, and private communication.</p>
<p>Further, Mir allows users to <a href="./applications/walled.html">escape</a> walled gardens, by allowing identifiers to be used outside of their originating services. Consider a hypothetical social network: MugTome. Without cooperation from MugTome, applications using Mir would enable users to distribute posts to their existing networks, authenticated with their MugTome identifiers, without touching MugTome servers.</p>
<p>Mir's goal is an Internet that is more secure, more equitable, and more free.</p>
<a class="header" href="#what-is-mir" id="what-is-mir"><h1>What is Mir?</h1></a>
<p>Mir, short for <strong>Peer-to-Peer Identification and Recovery</strong>, is a protocol that maps existing, human-understandable identifiers, like social media accounts, email addresses, and URLs, to addresses that are bound to sets of public keys.</p>
<p>Addresses are <a href="./protocol/cryptographic_wills.html">verifiably recoverable</a>: even if all of their devices and backup keys are lost, users can still recover the ability to authenticate. This solves a major problem in cryptographic protocols, that losing key material means the permanent loss of funds and the ability to send and receive messages. Further, even if the entire Mir network is compromised by an attacker, addresses are resistant to malicious key bindings. Addresses are intended to be <em>stable</em>: remaining the same even if devices are added or removed.</p>
<p>Provably associating identifiers with public keys allows key verification and lookup to occur implicitly. Users can reason about keys based on the semantic properties of an identifier, rather than a public key fingerprint. For example, a user could send an encrypted message or cryptocurrency directly to an email contact, rather than to a Base 58 encoded string. Likewise, she can trust an incoming encrypted message from a friend, without manually confirming a public key.</p>
<p>Mir also provides consistency for a user's public key set: adding or removing a device and key pair doesn't require registering the change with all of a user's services or websites. This consistency property can be extended to arbitrary data: a user could commit to the state of a social networking profile, a desired email provider distinct from his email's domain, etc. Further, Mir provides efficient proofs that a key is valid, so an authentication protocol like OAuth could be replicated with a simple proof of inclusion, rather than a handshake with a third-party service.</p>
<p>Anyone can run a node in Mir, and Mir provides succinct proofs that can be used on mobile and space- and bandwidth-limited devices. Mir is censorship-resistant: anyone can register an address, and anyone can map an identifier to an address. Some <a href="./applications.html">applications</a> of Mir are: improved password-replacement authentication schemes, cryptocurrencies that are usable by everyone, encrypted communication that resists MITM attacks, and &quot;forced disintermediation&quot;, the replacement of walled gardens, like social media services and email providers, with alternatives that promote different values, like an ad-free experience or a client designed to minimze time wasted, but rely on the same identifiers, networks, and data.</p>
<a class="header" href="#why-mir" id="why-mir"><h1>Why Mir?</h1></a>
<p>A small group of providers controls how Internet users communicate, transact, and authenticate. This is bad: single points of failure are vulnerable to compromise; divergent incentives lead to coercion, addiction, and the loss of privacy and attention; and lack of competition allows providers to force monolithic interfaces and algorithms on their users.</p>
<p>Cryptographic protocols offer an alternative to incumbent services, with greater security and privacy, but reduced usability. Key verification and management are difficult [<a href="http://cacr.uwaterloo.ca/techreports/2015/cacr2015-02.pdf">1</a>,<a href="https://arxiv.org/pdf/1802.04351.pdf">2</a>], and losing key material means the irreversible loss of funds and of the ability to authenticate and communicate.</p>
<p>A solution is necessary to compete with existing centralized services. This section:</p>
<ul>
<li>
<p><a href="./why/criteria.html">Provides the desiderata</a> for such a solution</p>
</li>
<li>
<p><a href="./why/related.html">Surveys the related work</a> in the field</p>
</li>
<li>
<p><a href="./why/advantages.html">Presents the advantages</a> of Mir over existing solutions</p>
</li>
</ul>
<a class="header" href="#desired-properties" id="desired-properties"><h1>Desired Properties</h1></a>
<p>A peer-to-peer identification and recovery protocol should have the following properties.</p>
<p>It should be peer-to-peer and open-source: designed so that its incentives are necessarily the incentives of its users. This guarantees that a single actor can't subvert, restrict access to, or control the system. Further, a peer-to-peer and open-source protocol is easy to fork, so incommensurable differences between groups of users can be resolved with competing versions of the protocol.</p>
<p>It should solve the problem of key loss and allow users to resume access, even if all of their devices and backup keys are lost. It's unrealistic to expect that the average user will never lose key material, so the current choice is between users being locked in or locked out: being forced to keep using centralized services that offer account recovery, or permanently losing access to decentralized services.</p>
<p>It should be capable of uniquely associating existing identifiers with sets of public keys, so that these identifiers can be used to verify public keys and authenticate data. The options for verifying and retrieving public keys are: to trust centralized servers to return correct key bindings (as in iMessage and Whatsapp), to manually verify public key fingerprints, or to use human-readable names. All of these options present problems: the first is susceptible to misbehaving providers and restricts federation and alternative clients, the second is unusable, and the last is susceptible to the human failure to distinguish between similar names. Users should be able to verify and retrieve public keys using the semantic properties of identifiers, like the content of a social media profile or an email contact relationship.</p>
<p>It should protect the validity of key bindings, even in the case that all other nodes are controlled by an attacker. This guarantees that a consensus failure doesn't allow attackers to maliciously change the public keys that are bound to an address.</p>
<p>Finally, it should support succinct proofs, allowing use on mobile phones and space- and bandwidth-limited devices. Services wouldn't have to run full nodes, or query from a set of trusted nodes to trust the validity of a provided binding.</p>
<a class="header" href="#related-work" id="related-work"><h1>Related Work</h1></a>
<p>Naming on the Internet, especially as it relates to public key verification, is an extensively-researched and important area. The goal is proving with a high degree of certainty that a name or identifier is uniquely mapped to a public key or set of public keys, such that a prover can't <em>equivocate</em>: provide conflicting mappings to different parties. This section will examine different types of solutions, their positive attributes, and their drawbacks.</p>
<p>The first ype consists of centralized service providers issuing authoritative name:key bindings within a namespace, which we'll refer to as the centralized model. Representatives of this class include encrypted messaging providers like Signal, iMessage, and Whatsapp, as well as consortia like Certificate Authorities. Under this model, providers return the public key or certificate associated with a name or account. This model allows for the widespread use of encrypted services without requiring people to explicitly reason about public keys, and benefits from the efficiency of centralized providers. However, providers are vulnerable to technical compromise and legal or extra-legal coercion, or might simply misbehave. While the returned public key can potentially be verified out-of-band with a fingerprint, there is otherwise no provable guarantee of correctness or even consistency of key bindings. Transparency log-based tools like CONIKS and Certificate Transparency make it harder for a provider to equivocate without detection, but it's unclear how to prevent malicious key bindings in the first place (critical for an application like cryptocurrency), or how to recover from a forked log. We'll refer to centralized services that provide auditability as the auditable centralized model.</p>
<p>Keybase occupies an intermediate space between the centralized and decentralized types. It allows anyone to register a name and associate public keys with that name, and it's responsible for popularizing the proof-of-identity model, where users can associate identifiers from other services with their Keybase accounts. It's made tremendous progress in improving the usability of end-to-end encrypted software, and even offers auditability by periodically committing a log to a Bitcoin transaction. However, Keybase suffers from certain drawbacks. Many of these are shared with the decentralized class and revolve around the difficulty of efficiently verifying bindings, but Keybase also faces the same challenges as auditable centralized providers. The fact that there's no way to detect a malicious binding when it's received, only equivocation when a log is published, means that Keybase is unsuited for applications like cryptocurrencies. Even if equivocation were detected, it's unclear how Keybase would recover from a forked log. In a decentralized protocol, misbehaving nodes can be penalized and the protocol can resume operation, but a centralized service can't penalize itself, and it doesn't have the same opportunity to programmatically recover from a fork and retain the trust of its users.</p>
<p>The second type consists of decentralized services that allocate names from within a namespace without a central authority, like Namecoin, Blockstack, and the Ethereum Name Service. These services avoid the problem of a single point-of-failure and provide open source codebases that can be run by anyone, resisting censorship and allowing their communities to fork in the case of incommensurable differences. Since there's no central authority, it's much more difficult for a single actor to subvert the protocol if its incentives diverge from those of other users. Further, since all nodes validate bindings, it's much more difficult and expensive to maliciously update bindings.</p>
<p>However, existing decentralized services suffer from a number of problems. First, they allocate names from a new and limited namespace, which is unnecessary, since users already have numerous identifiers. This requires a pricing or auction mechanism to prevent spam and squatting, and presents an additional cost for honest users. Second, there's no system that allows users to verify the uniqueness of identifier:address bindings, so an attacker could temporarily compromise a user's external account and edit a previous post to point a proof of identity at a malicious address. Most importantly, there's no way to efficiently verify that a binding is correct without running a full node, which is impossible on mobile devices. There's no way to prevent an adversary who controlled the network from maliciously updating bindings, and services like Namecoin have been shown to be vulnerable to 51% attacks. Finally, no decentralized service allows address recovery beyond a previously-registered backup key, which is unfriendly to users who have no experience with backup keys, and might lose all of their devices.</p>
<a class="header" href="#advantages-of-mir" id="advantages-of-mir"><h1>Advantages of Mir</h1></a>
<p>This section will discuss the following advantages of Mir.</p>
<ul>
<li>
<p>It's peer-to-peer, so it doesn't have a single point of failure, is censorship-resistant, can't be subverted by a single actor, and can penalize misbehaving nodes, allowing normal operation to resume. Further, Mir can be forked, accommodating competing views of how the protocol should function.</p>
</li>
<li>
<p>It allows users to recover from key loss, supporting a more user-friendly mode of operation where users don't need to reason about key management.</p>
</li>
<li>
<p>Address bindings are resistant to malicious updates: even if attackers control the network, the worst case is that they can roll back the state of a binding to a point where they can validly fork it, but this assumes that they have the required set of signatures to satisfy a cryptographic will. Otherwise, bindings can't be arbitrarily updated to include a malicious key.</p>
</li>
<li>
<p>It allows for efficient verification of both key bindings and optional globally-consistent state parameters, supporting operation on mobile devices, and removing the requirement that services that depend on Mir have to run a full node.</p>
</li>
<li>
<p>The mapping from an external identifier to an address is provably unique, so malicious mappings can be detected.</p>
</li>
<li>
<p>Addresses are just images of cryptographic hash functions, so they're fungible, and there isn't a need for an auction or pricing system to deter spammers and squatters. There's no penalty for late adopters who have missed out on premium names.</p>
</li>
</ul>
<a class="header" href="#protocol-overview" id="protocol-overview"><h1>Protocol Overview</h1></a>
<p>This section will discuss the details of the protocol and is organized as follows:</p>
<ul>
<li>
<p><a href="./protocol/architecture.html">Architecture</a> gives an overview of the core data structures.</p>
</li>
<li>
<p><a href="./protocol/address.html">Address Mappings</a> concerns how addresses are registered, represented, and used.</p>
<ul>
<li><a href="./protocol/cryptographic_wills.html">Cryptographic Wills</a> discusses verifiable address recovery.</li>
<li><a href="./protocol/format.html">Implementation</a> discusses implementation of cryptographic wills.</li>
<li><a href="./protocol/delegation.html">Untrusted Delegation</a> examines strategies to improve performance in Mir.</li>
</ul>
</li>
<li>
<p><a href="./protocol/identifier.html">Identifier Mappings</a> shows how identifiers are mapped to keys through addresses.</p>
<ul>
<li><a href="./protocol/identity.html">Proofs of Identity</a> gives examples of mapping different types of identifiers.</li>
<li><a href="./protocol/zk_address_mapping.html">ZK Address Mapping</a> discusses mapping identifiers while maintaining privacy.</li>
</ul>
</li>
<li>
<p><a href="./protocol/validation.html">Validation</a> gives the rules for updating the state of an address or identifier mapping.</p>
</li>
<li>
<p><a href="./protocol/consensus.html">Consensus</a> discusses possible consensus protocols, incentives, and governance.</p>
</li>
<li>
<p><a href="./protocol/security.html">Security</a> examines the security model and potential attacks.</p>
</li>
<li>
<p><a href="./protocol/further_improvements">Further Improvements</a> targets goals for future improvements to Mir.</p>
</li>
</ul>
<a class="header" href="#architecture" id="architecture"><h1>Architecture</h1></a>
<p>Mir uses a Merkle Prefix Tree (following <a href="https://eprint.iacr.org/2014/1004.pdf">CONIKS</a>) for the <strong>address tree</strong> and the <strong>identifier tree</strong>, such that the path to a leaf is uniquely determined by the prefix of the corresponding key (in the key/value sense). This yields efficient proofs that a key is either absent from the tree (proof of absence), or included in the tree (standard Merkle proof) and included only once.</p>
<p><img style="float: center;" src="/theme/identifier_address_tree.png"></p>
<p>Updates to the address tree and identifier tree (transactions) are submitted by nodes in balanced Merkle trees (blocks), such that each block references a parent block (or multiple parent blocks, depending on the consensus protocol) and the state of both trees after applying the parent block.</p>
<p>The address tree is designed to uniquely map addresses to a set consisting of keys and a <a href="./protocol/cryptographic_wills.html">cryptographic will</a>, an encoding of the conditions under which a set of signatures may update, recover, and revoke an address. The address itself is deterministically generated from an initial set of keys, a recent block root hash, and an initial cryptographic will. This is discussed in more detail in the <a href="./protocol/address.html">next section</a>, but it allows a prover to prove that a value \(V_n\) bound to an address is the product of valid transitions from the address, or \(A = V_0 \to V_n\). Providing a malicious binding \(A:V'\) would require compromising the cryptographic will at some point, or finding a collision in the cryptographic hash function used to generate the address. Since distributed data structures can be subverted, this is critical for the security of the protocol.</p>
<p>Identifier mappings consist of three components: a pointer to a proof of identity showing that the owner of an identifier is mapping it to an address, like a social media post, a DKIM signature, or CONIKS proof; the address or a commitment to a ZK proof used to establish the address; and a counter used to prevent replay attacks. A string uniquely representing to the identifier is hashed with the namespace of the identifier and the rules for a correct proof (used to distinguish between email addresses and social networking profiles in the same domain, for example). Other services store proofs of identity and make them accessible to users, but Mir is the first peer-to-peer service where mappings between identifiers and addresses are provably unique. This is critical because otherwise an attacker with temporary access to an external account could undetectably map that identifier to a separate address.</p>
<a class="header" href="#address-mappings" id="address-mappings"><h1>Address Mappings</h1></a>
<p>Let \( H:\{0,1\}^* \to \{0,1\}^{256} \) be a cryptographic hash function. Let \(C\) be the hash of the encoding of a <a href="./protocol/cryptographic_wills.html">cryptographic will</a> specifying the conditions under which the address value may be updated. Let \(B\) be the root hash of a previous block, and let \(K\) be the Merkle root of a tree consisting of public keys. An address \(A\) and bound value \(V\) are registered as:
$$ A = H(K || B || C ), V = A $$ The binding \(A:V\) is added to a block on registration, along with a valid proof of absence of \(A\) in the <strong>address tree</strong>. Updating from \(V_n \to V_{n+1} \) requires \(P\), a proof showing that the conditions of the cryptographic will in \(V_n\) are satisfied, and \(V_{n+1}\) is generated as:
$$ V_{n+1} = H(K' || V_{n} || C') $$ where \(K',C'\) are defined as above. This construction guarantees that even if all of the nodes in the network are malicious, they can't arbitrarily bind a key to an address and prove to an honest third-party that the binding is valid, since the value of an address at any point is chained back to the address itself, which is deterministically generated using the original cryptographic will.</p>
<p>In other words, providing a binding \(A:V_n\) always requires both a proof-of-inclusion in the address tree and a proof or series of proofs showing that the transitions from \(V_0 = A \to V_n \) are valid according to the cryptographic will at each point. This proves that the value bound to an address is the valid product of a set of state transitions according to valid cryptographic wills, and that the particular value bound to an address is consistent across the network, ensuring that each user has a snapshot of the latest valid keys associated with other users, and that compromised keys are detected.</p>
<p>Note that since addresses are 32-byte values that are generated as the image of a cryptographic hash function, they have no intrinsic value, unlike memorable names. This means that there are no issues with squatters or spammers in the address space, and there's no need to build an auction mechanism or price particular names. This removes a barrier to using Mir that is present in other systems that allocate from a namespace.</p>
<a class="header" href="#cryptographic-wills" id="cryptographic-wills"><h1>Cryptographic Wills</h1></a>
<p>A cryptographic will is an encoding of the conditions under which a set of signatures can update, recover, or revoke an address. Cryptographic wills offer a distinct advantage over other systems where an address is determined by a single public key, and where losing the associated private key means losing all funds stored at that address.</p>
<p>The intuition behind cryptographic wills is straightforward: when we register for centralized services, we accept a method for recovering access if we lose our password. In peer-to-peer services, by contrast, there's no central, trusted authority that can verify our identities and reset our public key set. However, users can still choose how to recover an address by specifying a set of friends, an identifier like an email address, a trusted identity-verifying service, the fingerprint of a backup key, or nothing at all.</p>
<p>Mir allows users to specify these conditions with AND, OR, and N-of-M operators. For example, I could specify that to update my address, signatures from 2-of-5 keys in my key set are required to add a new key, but 4-of-5 are required to update my cryptographic will. I could specify that (5-7 of some set of close friends and a trusted address recovery service) or 7-of-7 friends are required to recover my address.</p>
<p>Mir supports specifying separate conditions for an <strong>update</strong> transaction for the key set and the cryptographic will. A user can refer to keys already in the key set by the order in which they were added, or by a simple N-of-M condition. The goal is to prevent an attacker from compromising some subset of devices and removing the ability to recover an address by updating the cryptographic will.</p>
<p>A <strong>recover</strong> transaction occurs in the case that a user has lost all keys, or at least the minimum threshold necessary for adding new keys. In order to recover an address, a user provides a set of signatures satisfying one of the recovery conditions and the updated signed value.</p>
<p>A <strong>revoke</strong> transaction occurs in the case that all of a user’s keys have been stolen, or at least enough to remove all keys controlled by that user, and add keys controlled by an attacker. The end-result of a revocation is to place a tombstone at the address so that it can no longer be used.</p>
<a class="header" href="#format-and-proof-structure" id="format-and-proof-structure"><h1>Format and Proof Structure</h1></a>
<p><strong>Discuss possible encodings: MAST, polynomial, etc, and succinct, non-interactive proofs</strong></p>
<a class="header" href="#untrusted-delegation" id="untrusted-delegation"><h1>Untrusted Delegation</h1></a>
<p>The main issue with censorship-resistant, peer-to-peer services is a lack of scale. Bitcoin is notorious for only supporting 7 transactions per second, and no other distributed service has been able to maintain a high transaction rate and security guarantees in production.</p>
<p>We believe that Mir can improve on the performance of existing services by implementing a Proof-of-Stake consensus mechanism, sharding, and using SNARKs to make validation more efficient and increase block size. However, it's difficult to see how any of these solutions could scale the transaction layer to support billions of users relying on Mir, especially if Mir is to maintain a globally consistent state layer for things like social networking. The goal is for Mir to be operable immediately, at Internet scale, without compromising on the security of the protocol.</p>
<p>One solution that might fill the gap between what is currently possible and the needs of billions of Internet users we refer to as <strong>untrusted delegation</strong>. Recall that an address binding on Mir is expressed as: $$ A:V_n = A:H(K || V_{n-1} || C) $$ where \(K\) is the root hash of a Merkle tree and \(C\) is the hash of an encoding of a cryptographic will. \(K\) is intended to be the root of a tree of public keys, but a user can also set a leaf to be a pointer to an untrusted third-party service. This service could then provide address updates without committing them to the address tree.</p>
<p>The same security guarantees regarding malicious address bindings are still guaranteed by the cryptographic will and address itself - it would be impossible for the delegate service to provide a malicious binding without also proving a valid path from the value of the address in the address tree to the value of the malicious binding. Therefore, a user is only sacrificing consistency and censorship-resistance: it would be possible for a delegate to censor updates to an address or revert back to a previously-valid address. The worst-case isn't devastating though, since the user could just update the pointer to delegate a different service, or commit updates to the address tree directly.</p>
<p>This scheme offers incentive alignment through deterrence: delegate services are disincentivized from misbehaving because it's easy for users to exit and switch delegates. Users can use untrusted delegation to update their address bindings at a lower cost, and to provide global state for things like the value of a user's social networking profile at a particular time, or a pointer to a user's messaging or email provider.</p>
<a class="header" href="#identifier-mappings" id="identifier-mappings"><h1>Identifier Mappings</h1></a>
<p>A core design goal of Mir is allowing existing human-understandable identifiers to be verifiably mapped to unique addresses, without requiring cooperation from underlying services that issue those identifiers. Other systems like Keybase have demonstrated that this is possible: users can post publicly-verifiable proofs of identity on external services that point to names on another platform. However, the uniqueness property isn't efficiently verifiable. This is important, since an attacker could briefly compromise a user's social media account and edit a past post to be a proof of identity for a malicious address, which would be difficult to detect.</p>
<p>Mir satisfies this condition with the following registration process. Let \( H:\{0,1\}^* \to \{0,1\}^{256} \) be a cryptographic hash function, let \(A\) be an address, and let \(i\) be a string that uniquely refers to an identifier (an email address, social media handle, etc). Let \( l = 0 \) be a counter. To register an identifier mapping on Mir, a user would first create a publicly-verifiable proof containing \( H( l || A) \). In Mir, namespaces are organized as domains and verification rules. Rules give the process for verifying a proof of identity, and distinguish between different identifiers that are located on the same domain, like email addresses and social media accounts. For a domain string \(d\) and hashed verification rules \(v\), the full path to a leaf containing identifier mapping is generated as $$ I = H(d || v || i), I:H(k || p || A)  $$ for a pointer, \(p\), to the proof containing \( H( l || A) \).</p>
<p>Verifying a provided mapping consists of calculating the proof of inclusion in the identifier tree, and separately verifying the proof of identity according to the verification rules. This could entail accessing a social media post, verifying a DKIM signature, or verifying a CONIKS proof. It's important to note that the only validation of an identifier mapping consists of verifying that the counter is properly incremented and that any signature data exposed to the protocol, as in DKIM or CONIKS, is valid. This process allows false mappings from identifiers like social media accounts to be registered, though this isn't a critical security risk, since the protocol requires checking the validity of the external proof separately from the proof of inclusion. The problem is that external resources can be manipulated, or unavailable for legitimate as well as illegitimate reasons, so forcing validators to stake tokens and vote on the validity of every external resource could have a negative effect.</p>
<p>Future work will examine how to mitigate this, possibly with some form of delegation and a challenge process, such that a user could delegate to a staked validator upon registration of an identifier mapping, and the validator's signature would be required on all subsequent updates. Users could challenge misbehaving validators, who would then lose their stake based on a vote. Another option would be to have a two-phase process, where an address would submit a transaction to prepare an identifier to be mapped, and another address could then pay tokens equal to the first address's transaction fee, multiplied by some factor, to challenge registration of an identifier mapping. This process would repeat, exponentially increasing the fee in a series of rounds, each lasting some number of blocks, until one party could no longer pay. The winning address would receive spent tokens back, less some fees, while the tokens belonging to the losing address would be burned. This is an imperfect process, but it at least makes spamming or vacuously registering identifiers unpredictably unprofitable, which should be a disincentive.</p>
<a class="header" href="#proof-of-identity" id="proof-of-identity"><h1>Proof of Identity</h1></a>
<p>Proofs of identity are statements used to prove that a particular identifier on an external service, like a social media account, email address, URL, etc. belongs to the owner of an address on Mir. We distinguish between two classes: <em>strongly-verifiable</em> and <em>weakly-verifiable</em> proofs of identity.</p>
<p>Strongly-verifiable proofs of identity are statements that are authenticated such that an update to an identifier mapping can be cryptographically verified outside of the originating service. Examples of strongly-verifiable proofs are DKIM-signed messages, CONIKS proofs-of-inclusion, etc. These proofs can be validated entirely within Mir, but it's important to note that the strong condition doesn't imply that a particular mapping from an identifier to an address is necessarily up-to-date, only that it is more current than the current state of the mapping in Mir. For instance, a CONIKS log could have \(t\) epochs, but the registered mapping for an identifier could use a proof from epoch \(t-n\). Any valid proof-of-inclusion from \((t-n,t]\) can be used to update the identifier mapping, even if it differs from the mapping at \(t\) (but obviously the mapping at \(t\)) will supersede all previous mappings). A solution to this issue is to simply construct a rule set such that the registrar of a namespace publishes CONIKS logs that consist of identifier:address mappings directly on Mir.</p>
<p>Weakly-verifiable proofs of identity are those that require accessing a third-party resource to verify. Counters prevent replay attacks, and the uniqueness of identifier:address mappings prevents an attacker from using a malicious proof of identity without detection. This is important, since otherwise, an attacker could temporarily compromise an external account, create a proof of identity that maps to a malicious address, and it would be difficult to detect. Examples of weakly-verifiable proofs are publicly-verifiable social media posts, DNS entries, etc.</p>
<a class="header" href="#zk-address-mapping" id="zk-address-mapping"><h1>ZK Address Mapping</h1></a>
<p><strong>Describe mapping from identifier to address in ZK, in order to prevent linking identifiers mapped to the same address.</strong></p>
<a class="header" href="#validation-rules" id="validation-rules"><h1>Validation Rules</h1></a>
<p><strong>Copy specific rules from whitepaper</strong></p>
<a class="header" href="#consensus" id="consensus"><h1>Consensus</h1></a>
<p><strong>Tokens for rate-limiting, Proof-of-Stake or Proof-of-Space, pricing of transaction fees, prove various liveness/availability properties, etc.</strong></p>
<a class="header" href="#security" id="security"><h1>Security</h1></a>
<p><strong>Give proofs of protocol security, both of address bindings and of consensus guarantees.</strong></p>
<a class="header" href="#further-work" id="further-work"><h1>Further Work</h1></a>
<p><strong>Recursive SNARK verification, preventing vacuous identifier mappings, preventing identifier linkage, etc.</strong></p>
<a class="header" href="#using-mir" id="using-mir"><h1>Using Mir</h1></a>
<p>Mir improves the usability of cryptographic protocols by removing the need for users to manage and verify public keys. Protocols for authentication, communication, and payments can benefit from the recovery from key loss and the implicit retrieval and verification of public keys that Mir provides. The goal is to allow anyone to use decentralized services directly, without sacrificing the usability of existing, centralized services.</p>
<p>On the other hand, Mir attacks a core problem of the modern Internet: the existence of walled gardens and lock-in due to network effects. Currently, most users depend on third parties like social media services and email providers to vouch for what is true. These intermediaries provide a valuable service by authenticating and relaying data between users, but also completely dictate their users' interfaces and experiences by preventing the use of alternative clients and leveraging network effects to keep their users locked-in.</p>
<p>Fundamentally, the core value that service providers offer is the trust that data is authentic and consistent, since storage and message passing are essentially commodities on the modern Internet. Mir simply offers a way to guarantee this trust by authenticating data under a particular identifier, without the involvement of the service that issued the identifier. Further, users can use Mir to share globally-consistent state, allowing different users to consume the same data through different interfaces and experiences.</p>
<p>This section examines in greater detail a few of the potential applications for Mir.</p>
<ul>
<li>
<p><a href="./applications/authentication.html">Authentication</a> gives improved passwordless authentication schemes.</p>
</li>
<li>
<p><a href="./applications/transaction.html">Transaction</a> details improved cryptocurrency and fiat models.</p>
</li>
<li>
<p><a href="./applications/communication.html">Communication</a> describes more transparent messaging protocols that resist MITM attacks.</p>
</li>
<li>
<p><a href="./applications/walled.html">Breaking Network Effects</a> shows how Mir could allow users to escape walled gardens.</p>
</li>
</ul>
<a class="header" href="#authentication" id="authentication"><h1>Authentication</h1></a>
<a class="header" href="#registration-and-login" id="registration-and-login"><h3>Registration and Login</h3></a>
<p>A user with address \(A\) and mapped identifier \(I\) could register for or log into an external service with either just an address or an identifier. In the case of just an address, recall that \(A:V\) is a binding where for cryptographic hash function \(H\), a merkle root of a set of keys \(K\), and cryptographic will \(C\), \(V = H(K || V' || C)\). A user could send a randomly-generated nonce to a site, receive a signed token deterministically generated using that nonce, and need to provide the following data:</p>
<ul>
<li>
<p>A succinct, non-interactive proof that shows that the state transition \(A \to V \) is the composition of valid state transitions at each \(V_n\) according to the cryptographic wills \(C_n\).</p>
</li>
<li>
<p>A proof of inclusion of \(A:V\) in the address tree.</p>
</li>
<li>
<p>For a key \(k\) on a device, a proof of inclusion \(k \in K \).</p>
</li>
<li>
<p>Optionally, a succinct, non-interactive proof that the address tree root is valid, if the service doesn't run a light node.</p>
</li>
<li>
<p>A signature of some provided token generated with \(k\)</p>
</li>
</ul>
<p>This might seem complicated, but is actually far simpler than requiring a network request to another service, as in OAuth, and provides a stronger guarantee of consistency: it's much harder to maliciously alter the secret that's used for authentication, and much easier to detect malicious alteration.</p>
<p>In the case of registering with an identifier \(I\), a user would need to provide the above data, as well as:</p>
<ul>
<li>
<p>A proof of inclusion of \(I:H(l:p:A\)) in the identifier tree, for counter \(l\) and proof/pointer \(p\).</p>
</li>
<li>
<p>Optionally, a succinct, non-interactive proof that the identifier tree root is valid.</p>
</li>
<li>
<p>A cryptographic proof that \(p\) is valid if \(I\) is a strongly-verifiable identifier, otherwise a pointer to a weakly-verifiable proof of identity.</p>
</li>
</ul>
<a class="header" href="#zk-signatures" id="zk-signatures"><h3>ZK Signatures</h3></a>
<a class="header" href="#transaction" id="transaction"><h1>Transaction</h1></a>
<p><strong>Describe a cryptocurrency where address recovery was possible, sending funds to an identifier was easily supported, etc.</strong></p>
<a class="header" href="#communication" id="communication"><h1>Communication</h1></a>
<p><strong>Describe using a simple proof-of-inclusion to verify a key, prevent MITM attack, like CONIKS</strong></p>
<a class="header" href="#breaking-network-effects" id="breaking-network-effects"><h1>Breaking Network Effects</h1></a>
<a class="header" href="#authenticating-data-with-an-identifier" id="authenticating-data-with-an-identifier"><h3>Authenticating Data with an Identifier</h3></a>
<p>Allowing users to keep their identifiers without requiring them to use the services that issue those identifiers is an important move forward in the development of the Internet. Even decentralized or federated services suffer from this problem: a user on a federated social network can't transport his identifier to a different instance than the one that issued it.</p>
<p>A user with address \(A\) and mapped identifier \(I\) could authenticate some message \(m\), such that it could be verified by another party. Recall that \(A:V\) is a binding where for cryptographic hash function \(H\), a merkle root of a set of keys \(K\), and cryptographic will \(C\), \(V = H(K || V' || C)\). A user could generate \(m\), and then provide the verifier with:</p>
<ul>
<li>
<p>A succinct, non-interactive proof that shows that the state transition \(A \to V \) is the composition of valid state transitions at each \(V_n\) according to the cryptographic wills \(C_n\).</p>
</li>
<li>
<p>A proof of inclusion of \(A:V\) in the address tree at some block.</p>
</li>
<li>
<p>For a key \(k\) on a device, a proof of inclusion \(k \in K \).</p>
</li>
<li>
<p>A signature of some provided token generated with \(k\)</p>
</li>
<li>
<p>A proof of inclusion of \(I:H(l:p:A\)) in the identifier tree at some block, for counter \(l\) and proof/pointer \(p\).</p>
</li>
<li>
<p>A cryptographic proof that \(p\) is valid if \(I\) is a strongly-verifiable identifier, otherwise a pointer to a weakly-verifiable proof of identity.</p>
</li>
<li>
<p>A signature of \(m\) by \(k\).</p>
</li>
</ul>
<p>Optionally, the verifier could request that the user provide a proof-of-inclusion in a later block for the address and identifier trees.</p>
<a class="header" href="#sharing-globally-consistent-state" id="sharing-globally-consistent-state"><h3>Sharing Globally-Consistent State</h3></a>
<p>Providing a globally-consistent view of some data is important for applications like social networking, where showing the latest state of a profile or feed is important. A user could prove to a verifier that some state parameter \(s = H(d)\) is the hashed value of some data by providing the following:</p>
<ul>
<li>
<p>A succinct, non-interactive proof that shows that the state transition \(A \to V \) is the composition of valid state transitions at each \(V_n\) according to the cryptographic wills \(C_n\).</p>
</li>
<li>
<p>A proof of inclusion of \(A:V\) in the address tree at some block.</p>
</li>
<li>
<p>A proof-of-inclusion \(s \in K \).</p>
</li>
</ul>
<a class="header" href="#faq" id="faq"><h1>FAQ</h1></a>
<p><strong>Various questions about protocol operation, yes it's better than multisig!</strong></p>
<p>Is PoS a better guarantee w/ recursive snarks?</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
